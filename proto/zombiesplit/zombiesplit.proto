// The zombiesplit wire protocol.
//
// The wire protocol is asymmetric: the requests API forms an RPC layer,
// and the responses API is a flat messaging stream.
syntax = "proto3";
package zombiesplit;

//
// Request RPC
//

// Service providing actions clients can send to servers.
service Request {
  // Requests an initial dump.
  rpc Dump(DumpRequest) returns (DumpResponse) {}

  // Starts a new run in the current session.
  rpc NewRun(NewRunRequest) returns (NewRunResponse) {}

  // Modifies a split in the current session.
  rpc ModifySplit(ModifySplitRequest) returns (ModifySplitResponse) {}

  // Requests that we begin observing.
  rpc Observe(ObserveRequest) returns (stream Event) {}
}

//
// Dump
//

// A dump request.
message DumpRequest {
  // Space for rent
  // This may accept filters later on.
}

// A dump response.
// Currently this does not contain any information, but eventually it will
// contain the full dump.
message DumpResponse {
  // Server semantic version.
  message Version {
    uint32 major = 1; // Major version number.
    uint32 minor = 2; // Minor version number.
    uint32 patch = 3; // Patch version number.
  }

  // Information about the session that the server is running.
  message Session {
    // Information about a split.
    message Split {
      string sid = 1;  // Short identifier for the split.
      string name = 2; // Full name for the split.
    }

    string game_sid = 1;      // Short identifier for the game.
    string category_sid = 2;  // Short identifier for the category.
    string game_name = 3;     // Full name for the game.
    string category_name = 4; // Full name for the category.
    repeated Split split = 5; // Information about a split.
  }

  Version server_version = 1; // The version of the server.
  Session session = 2;        // The current session.
  // TODO(@MattWindsor91): attempt dump
}

//
// NewRun
//

// A new-run request.
// This may accept filters later on.
message NewRunRequest {
  bool save = 1; // Should this run be saved to the database?
}

// A new-run response.
message NewRunResponse {
  // Space for rent
}

//
// ModifySplit
//

// A request to modify a particular split.
message ModifySplitRequest {
  // Types of pop modification.
  enum Pop {
    ONE = 0; // Pop the most recent time from this split.
    ALL = 1; // Pop all times from the split.
  }

  uint64 index = 1; // Index of the split.

  // Modification being requested.
  oneof modification {
    uint32 push = 2; // Push this time (milliseconds) onto the split.
    Pop pop = 3; // Remove a certain amount of times from the split.
  }
}

// A response from a split modification.
message ModifySplitResponse {
  // Space for rent
}

//
// Observe
//

message ObserveRequest {
  // This might contain a mask eventually.
}

// An event that has occurred on the session.
message Event {
  // Enumeration of control events.
  enum Control {
    NOP = 0; // Zero value for control events.
    RESET = 1; // Reset run.
  }
  // An event on a split.
  message Split {
    // An event on a split time.
    message Time {
      // Enumeration of types of time event.
      enum Type {
        PUSHED = 0;     // This time was just added to the split.
        POPPED = 1;     // This time was just removed from the split.
        TOTAL = 2;      // This is the new total for the split.
        COMPARISON = 3; // This is the new comparison for the split.
      }
      Type type = 1;   // The type of time event.
      uint32 time = 2; // The time, in milliseconds.
    }

    uint64 index = 1; // Index of the split.

    // Payload of the event.
    oneof payload {
      Time time = 2;  // Something happened to the split time.
      Pace pace = 3;  // The split has been re-paced.
      bool is_pb = 4; // Is the split a personal best?
    }
  }

  // Payload of the event.
  oneof payload {
    Control control = 1;     // A control event.
    Split split = 2;    // An event on a split.
    Aggregate aggregate = 3; // An aggregate time announcement.
  }
}

// An aggregate time announcement.
message Aggregate {
  // Enumeration of types of aggregate.
  enum Type {
    ATTEMPT = 0;     // Total so far in the attempt.
    BEST_RUN = 1;    // Sum of segments in the best whole comparison run.
    SUM_OF_BEST = 2; // Sum of best segment times in the comparison.
  }

  Type type = 1;    // The type of aggregate.
  uint32 value = 2; // The value, in milliseconds.
  Pace pace = 3;    // The pace of this aggregate, if applicable.
}

// A pace note.
enum Pace {
  NONE = 0;               // Pacing information not available.
  BEHIND = 1;             // Behind comparison.
  BEHIND_BUT_GAINING = 2; // Behind comparison but making up time.
  AHEAD_BUT_LOSING = 3;   // Ahead of comparison but losing time.
  AHEAD = 4;              // Ahead of comparison.
}