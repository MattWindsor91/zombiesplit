// The zombiesplit gRPC protocol.
syntax = "proto3";
package zombiesplit;

// The zombiesplit gRPC service.
//
// The zombiesplit API has a strong command-query separation, so commands
// generally don't return any information.  Instead, use `Observe` to
// subscribe to events, and monitor those.
//
// We give commands separate response messages, just in case this situation
// changes.
service Zombiesplit {
  /*
   * Queries
   */

  // Requests an initial dump.
  //
  // Use this before starting the user interface, or if the client has lagged
  // behind its observation stream and needs a full refresh.
  rpc Dump(DumpRequest) returns (DumpResponse) {}

  // Requests an observation stream.
  //
  // Use this to subscribe the client to observations.
  rpc Observe(ObserveRequest) returns (stream Event) {}

  /*
   * Commands
   */

  // Starts a new run in the current session.
  rpc NewRun(NewRunRequest) returns (NewRunResponse) {}

  // Modifies a split in the current session.
  rpc ModifySplit(ModifySplitRequest) returns (ModifySplitResponse) {}
}

//
// Dump
//

// A dump request.
message DumpRequest {
  // Space for rent
  // This may accept filters later on.
}

// A dump response.
// Currently this does not contain any information, but eventually it will
// contain the full dump.
message DumpResponse {
  // Information about the server.
  message Server {
    // Server semantic version.
    message Version {
      uint64 major = 1; // Major version number.
      uint64 minor = 2; // Minor version number.
      uint64 patch = 3; // Patch version number.
    }

    string ident = 1;    // The name of the server software.
    Version version = 2; // The version of the server.
  }

  // Information about the session that the server is running.
  message Run {
    // Information about a game/category.
    message GameCategory {
      string game_sid = 1;      // Short identifier for the game.
      string category_sid = 2;  // Short identifier for the category.
      string game_name = 3;     // Full name for the game.
      string category_name = 4; // Full name for the category.
    }
    // Information about a split marker.
    message Split {
      string sid = 1;            // Short identifier for the split.
      string name = 2;           // Full name for the split.
      repeated uint32 times = 3; // Times for the split.
    }

    GameCategory game_category = 1; // Game/category information.
    AttemptInfo attempt_info = 2;   // Current attempt information.
    repeated Split splits = 3;      // Information about a split.
  }

  Server server = 1; // Server information.
  Run run = 2;       // Dump of the current run state.
}

//
// NewRun
//

// A new-run request.
// This may accept filters later on.
message NewRunRequest {
  bool save = 1; // Should this run be saved to the database?
}

// A new-run response.
message NewRunResponse {
  // Space for rent
}

//
// ModifySplit
//

// A request to modify a particular split.
message ModifySplitRequest {
  // Types of pop modification.
  enum Pop {
    ONE = 0; // Pop the most recent time from this split.
    ALL = 1; // Pop all times from the split.
  }

  uint64 index = 1; // Index of the split.

  // Modification being requested.
  oneof modification {
    uint32 push = 2; // Push this time (milliseconds) onto the split.
    Pop pop = 3;     // Remove a certain amount of times from the split.
  }
}

// A response from a split modification.
message ModifySplitResponse {
  // Space for rent
}

//
// Observe
//

message ObserveRequest {
  // This might contain a mask eventually.
}

// An event that has occurred on the session.
message Event {
  // An event on a split.
  message Split {
    // An event on a split time.
    message Time {
      // Enumeration of types of time event.
      enum Type {
        PUSHED = 0;     // This time was just added to the split.
        POPPED = 1;     // This time was just removed from the split.
        TOTAL = 2;      // This is the new total for the split.
        COMPARISON = 3; // This is the new comparison for the split.
      }
      Type type = 1;   // The type of time event.
      uint32 time = 2; // The time, in milliseconds.
    }

    uint64 index = 1; // Index of the split.

    // Payload of the event.
    oneof payload {
      Time time = 2;  // Something happened to the split time.
      Pace pace = 3;  // The split has been re-paced.
      bool is_pb = 4; // Is the split a personal best?
    }
  }

  // Payload of the event.
  oneof payload {
    AttemptInfo reset = 1; // A new attempt has started; the new attempt's information follows.
    Split split = 2;       // An event on a split.
    Aggregate total = 3;   // A whole-run total time announcement.
  }
}

// An aggregate time announcement.
message Aggregate {
  // Enumeration of types of aggregate.
  enum Type {
    ATTEMPT = 0;     // Total so far in the attempt.
    COMPARISON = 1;  // Sum of segments in the best whole comparison run.
    SUM_OF_BEST = 2; // Sum of best segment times in the comparison.
  }

  Type type = 1;    // The type of aggregate.
  uint32 value = 2; // The value, in milliseconds.
  Pace pace = 3;    // The pace of this aggregate, if applicable.
}

// Attempt information.
//
// This is both sent in dumps as well as whenever a new attempt begins.
message AttemptInfo {
  uint64 total     = 1; // How many attempts have been run so far (ie. one below the current run's number).
  uint64 completed = 2; // How many attempts have been run to completion so far.
}

// A pace note.
enum Pace {
  NONE = 0;               // Pacing information not available.
  BEHIND = 1;             // Behind comparison.
  BEHIND_BUT_GAINING = 2; // Behind comparison but making up time.
  AHEAD_BUT_LOSING = 3;   // Ahead of comparison but losing time.
  AHEAD = 4;              // Ahead of comparison.
}